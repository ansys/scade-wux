# Copyright (C) 2020 - 2026 ANSYS, Inc. and/or its affiliates.
# SPDX-License-Identifier: MIT
#
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

"""
SCADE Code Generator extension for unit testing Ansys SCADE Wrapper Tools.

It logs the calls to the callbacks triggered by the SCADE Simulator
or the Generic Integration wrapper.

It has two command line parameters:

* `max_steps`: maximum number of steps to execute.
* `max_log`: maximum number of logged steps.
"""

from pathlib import Path

import scade.code.suite.sctoc as sctoc
from scade.model.project.stdproject import Configuration, Project

import ansys.scade.wux.wux as wux


class Extension:
    """
    Implements the WUX unit test extension (``WUX2_UT_EXT``).

    Refer to *Generation Module* in the User Documentation,
    section *3/ Code Integration Toolbox/Declaring Code Generator Extension*.
    """

    # identification
    tool = 'WUX Unit Test Extension'
    version = '0.1'
    banner = '%s %s' % (tool, version)

    script_path = Path(__file__)
    script_dir = script_path.parent

    # generated files
    sources = []

    @classmethod
    def get_services(cls):
        """Declare the generation service GoWrapper."""
        # the ID is meaningless, the service declared by this module
        # is activated automatically when the module is selected
        # in the Code Generator integration settings
        ext = (
            '<UNUSED WUX2_UT_EXT>',
            ('-OnInit', Extension.init),
            ('-OnGenerate', Extension.generate),
            ('-OnBuild', Extension.build),
        )
        return [ext]

    @classmethod
    def init(cls, target_dir: str, project: Project, configuration: Configuration):
        """Declare the required generation services and the execution order."""
        ctx = ('WUX2_CTX', ('-Order', 'Before'))
        simu_ext = ('WUX2_SIMU_EXT', ('-Order', 'Before'))
        return [ctx, simu_ext]

    @classmethod
    def generate(cls, target_dir: str, project: Project, configuration: Configuration):
        """Generate the code for this generation service."""
        print(cls.banner)

        basename = Path(project.pathname).stem

        path = Path(target_dir) / ('wuxutext%s.c' % basename)
        with path.open('w') as f:
            wux.gen_header(f, 'Generated by %s' % cls.banner)
            wux.gen_includes(f, ['WuxSimuExt.h', 'WuxUTExt.h', 'wuxctx%s.h' % basename])
            cls.generate_reset(f)
            cls.generate_inputs(f)
            cls.generate_outputs(f)
            wux.gen_footer(f)
        cls.sources.append(path)

        # declare the generated file
        sctoc.add_generated_files(cls.tool, [path.name])

        return True

    @classmethod
    def build(cls, target_dir, project, configuration):
        # add the extension's runtime file and the generated ones
        lib = cls.script_dir / 'lib'
        wux.add_sources([lib / 'WuxUTExt.cpp'] + cls.sources)
        # declare the include directories
        wux.add_includes([cls.script_dir / 'include'])

        return True

    @classmethod
    def generate_reset(cls, f):
        # static context
        wux.writeln(f, 0, '/* state */')
        wux.writeln(f, 0, 'static int nFirst = 1;')
        wux.writeln(f, 0, 'static int nLast = 0;')
        wux.writeln(f)
        wux.writeln(f, 0, 'void WuxUTExtReset()')
        wux.writeln(f, 0, '{')
        wux.writeln(f, 1, '/* reset nFirst */')
        wux.writeln(f, 1, 'nFirst = 1;')
        wux.writeln(f, 0, '}')
        wux.writeln(f)

    @classmethod
    def generate_inputs(cls, f):
        # search the root operators for the first integer input (why not?)
        c_path = ''
        for ip in wux.ips:
            op = ip.get_operator()
            for input in op.get_inputs():
                scade_path = input.get_scade_path()
                if ip.get_generated_type_name(scade_path) == 'kcg_int32':
                    c_path = ip.get_generated_path(scade_path)
                    break
            if c_path:
                break
        wux.writeln(f, 0, 'void WuxUTExtSetInputs()')
        wux.writeln(f, 0, '{')
        if c_path:
            wux.writeln(f, 1, '/* set the input to last except at first step */')
            wux.writeln(f, 1, 'if (nFirst) {')
            wux.writeln(f, 1, '    nFirst = 0;')
            wux.writeln(f, 1, '}')
            wux.writeln(f, 1, 'else {')
            wux.writeln(f, 1, '    %s = nLast;' % c_path)
            wux.writeln(f, 1, '}')
        else:
            wux.writeln(f, 1, '/* no integer input */')
        wux.writeln(f, 0, '}')
        wux.writeln(f)

    @classmethod
    def generate_outputs(cls, f):
        # search the root operators for the first integer output (again, why not?)
        c_path = ''
        for ip in wux.ips:
            op = ip.get_operator()
            for input in op.get_outputs():
                scade_path = input.get_scade_path()
                if ip.get_generated_type_name(scade_path) == 'kcg_int32':
                    c_path = ip.get_generated_path(scade_path)
                    break
            if c_path:
                break
        wux.writeln(f, 0, 'void WuxUTExtGetOutputs()')
        wux.writeln(f, 0, '{')
        if c_path:
            wux.writeln(f, 1, 'static char szBuffer[80];')
            wux.writeln(f)
            wux.writeln(f, 1, '/* store the value of the output */')
            wux.writeln(f, 1, 'nLast = %s;' % c_path)
            wux.writeln(f, 1, '/* log the value */')
            wux.writeln(f, 1, 'WuxLogf(SIM_INFO, "last = %d", nLast);')
        else:
            wux.writeln(f, 1, '/* no integer output */')
        wux.writeln(f, 0, '}')
        wux.writeln(f)
