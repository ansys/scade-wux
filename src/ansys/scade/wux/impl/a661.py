# Copyright (C) 2020 - 2024 ANSYS, Inc. and/or its affiliates.
# SPDX-License-Identifier: MIT
#
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

"""
A661 user applications integration code.

Extension for embedding UAs in other wrappers.
"""

import os
from pathlib import Path

import scade.code.suite.sctoc as sctoc
import scade.model.suite.displaycoupling as display

from ansys.scade.apitools.info import get_scade_home
from ansys.scade.wux import __version__
import ansys.scade.wux.wux as wux


class A661UAA:
    ID = 'WUX2_UAA'
    tool = 'SCADE Suite UA Adaptor Extension'
    banner = '%s (WUX %s)' % (tool, __version__)

    # prefix of genetared files
    PREFIX = 'wuxuaa'

    script_path = Path(__file__)
    script_dir = script_path.parent

    ansys_scade_dir = get_scade_home()

    # sources generated by this extension
    sources = []

    # a661 specs
    a661_specs = []
    ua_base_name = None
    host = None
    port = None
    config_file = None
    user_config = None

    # root operator (assume only one)
    root = None

    @classmethod
    def init(cls, target_dir, project, configuration):
        cg = ('Code Generator', ('-Order', 'Before'))
        ctx = ('WUX2_CTX', ('-Order', 'Before'))
        return [cg, ctx]

    @classmethod
    def generate(cls, target_dir, project, configuration):
        print(cls.banner)

        roots = wux.mf.get_root_operators()
        cls.root = roots[0]

        cls.set_a661_globals(target_dir, project, configuration)

        # run UA Adaptor if needed
        cls.run_uua(target_dir, project, configuration)

        cls.generate_interface(target_dir, project, configuration)

        cls.declare_target(target_dir, project, configuration)

        return True

    # ------------------------------------------------------------------------
    # interface file with UA generated files
    # ------------------------------------------------------------------------

    @classmethod
    def gen_includes(cls, f, project):
        f.write('/* includes */\n')
        # f.write('#include <windows.h>\n')
        # f.write('\n')
        f.write('/* SCADE Suite contexts */\n')
        f.write('#include "wuxctx%s.h"\n' % Path(project.pathname).stem)
        f.write('\n')
        if cls.ua_base_name is not None:
            f.write('/* UAA generated files */\n')
            f.write('#include "{0}.h"\n'.format(cls.ua_base_name))
            f.write('\n')
        f.write('/* interface protocols */\n')
        if cls.ua_base_name is not None:
            f.write('#include "A661Connect.h"\n')
        f.write('\n')
        f.write('#include "WuxA661Ext.h"\n')
        f.write('\n')

    @classmethod
    def gen_connect(cls, f):
        f.write('int WuxA661ConnectServer()\n')
        f.write('{\n')
        if cls.ua_base_name is not None:
            f.write(
                '    return 0 /* OK */ == A661ConnectServer("{0}", {1});\n'.format(
                    cls.host, cls.port
                )
            )
        else:
            f.write('    return 1;\n')
        f.write('}\n')
        f.write('\n')

    @classmethod
    def gen_disconnect(cls, f):
        f.write('int WuxA661DisconnectServer()\n')
        f.write('{\n')
        if cls.ua_base_name is not None:
            f.write('    return 0 /* OK */ == A661DisconnectServer();\n')
        else:
            f.write('    return 1;\n')
        f.write('}\n')
        f.write('\n')

    @classmethod
    def gen_receive(cls, f):
        f.write('void WuxA661ReceiveMessages()\n')
        f.write('{\n')
        if cls.ua_base_name is not None:
            # assume only one root node
            ip = wux.ips[0]
            # extended ip, cf. kcgcontext.py
            inctxvar = ip.get_in_context_var()
            addr = 'NULL' if len(cls.root.get_inputs()) == 0 or inctxvar == '' else '&' + inctxvar
            map = {'ua': cls.ua_base_name, 'addr': addr}
            code = (
                '    static buffer_el msg[{ua}_MAX_SIZE_INPUT_BUFFER];\n'
                '\n'
                '    /* receive from server */\n'
                '    {ua}_receive_clear({addr}, NULL);\n'
                '    if (A661Receive(msg, sizeof(msg)) == 0)\n'
                '        {ua}_receive(msg, sizeof(msg), {addr}, NULL);\n'
            )
            f.write(code.format_map(map))
        f.write('}\n')
        f.write('\n')

    @classmethod
    def gen_send(cls, f):
        f.write('void WuxA661SendMessages()\n')
        f.write('{\n')
        if cls.ua_base_name is not None:
            # assume only one root node
            ip = wux.ips[0]
            # extended ip, cf. kcgcontext.py
            outctxvar = ip.get_out_context_var()
            addr = (
                'NULL' if len(cls.root.get_outputs()) == 0 or outctxvar == '' else '&' + outctxvar
            )
            map = {'ua': cls.ua_base_name, 'addr': addr}
            code = (
                '    static buffer_el msg[{ua}_MAX_SIZE_OUTPUT_BUFFER];\n'
                '\n'
                '    uaa_size len = {ua}_send(msg, {addr}, NULL);\n'
                '    /* send to server */\n'
                '    A661Send(msg, (int) len);\n'
            )
            f.write(code.format_map(map))
        f.write('}\n')
        f.write('\n')

    @classmethod
    def generate_interface(cls, target_dir, project, configuration):
        path = Path(project.pathname)
        pathname = Path(target_dir) / (cls.PREFIX + path.stem + '.c')
        sctoc.add_generated_files(cls.tool, [pathname.name])
        cls.sources.append(pathname)
        with open(str(pathname), 'w') as f:
            wux.gen_header(f, cls.banner)
            cls.gen_includes(f, project)
            # gen_kcg_declarations(f)
            # gen_period(f)
            # gen_init(f)
            # gen_cycle(f)
            cls.gen_connect(f)
            cls.gen_disconnect(f)
            cls.gen_receive(f)
            cls.gen_send(f)
            wux.gen_footer(f)

    # ------------------------------------------------------------------------
    # UA Adaptor
    # ------------------------------------------------------------------------

    @classmethod
    def run_uua(cls, target_dir, project, configuration):
        # run UA Adaptor if needed
        if cls.ua_base_name is None:
            return
        uua = cls.ansys_scade_dir / 'SCADE' / 'bin' / 'uaadaptor.exe'
        sdy = Path(display.get_roots()[0].mapping_file.pathname).as_posix()
        trace = (Path(target_dir) / 'kcg_trace.xml').as_posix()
        hdr = cls.root.get_name() + '.h'
        # "%SCADE_DIR%\SCADE\bin\uaadaptor.exe" -sdy FuelManagementUA.sdy -n "%SCADE_DIR%/SCADE Display/config/a661_description/a661.xml" -outdir "UA" -k "KCG/kcg_trace.xml" -o "FuelManagementUA_FMUA_UA_1" -i "FuelManagementUA_interface.h"  -encoding "ASCII"  "../DF/FuelManagement.sgfx"
        uc = '' if cls.user_config == '' else ' -user_config "{0}"'.format(cls.user_config)
        command = '"{uua}" -sdy "{sdy}" -n "{conf}" -outdir "{dir}" -k "{trace}" -o {base}{uc} -i "{hdr}" -encoding "ASCII" "{sgfx}"'.format(
            uua=uua,
            sdy=sdy,
            conf=cls.config_file,
            dir=target_dir,
            trace=trace,
            base=cls.ua_base_name,
            uc=uc,
            hdr=hdr,
            sgfx=Path(cls.a661_specs[0].pathname).as_posix(),
        )
        print(command)
        ok = False
        with os.popen(command) as f:
            stdout = f.read()
            for line in stdout.split('\n'):
                tokens = line.split(': ')
                if tokens[0] == 'I0006':
                    path = Path(tokens[-1])
                    if path.suffix == '.c':
                        cls.sources.append(path)
                    sctoc.add_generated_files('UA Adaptor', [path.name])
                elif tokens[0] == 'I0808' and tokens[-1] == '[SUCCESSFUL]':
                    ok = True
            if not ok:
                print(stdout)

    # ------------------------------------------------------------------------
    # build
    # ------------------------------------------------------------------------

    @classmethod
    def declare_target(cls, target_dir, project, configuration):
        include = cls.script_dir.parent / 'include'
        wux.add_includes([include])
        if len(cls.sources) != 0:
            wux.add_sources(cls.sources)
            # code has been generated, add A661Connect to the makefile
            lib = cls.script_dir.parent / 'lib'
            wux.add_sources([lib / 'A661connect.c'])

    # ------------------------------------------------------------------------
    # settings
    # ------------------------------------------------------------------------

    @classmethod
    def is_spec_a661(cls, specification):
        project = specification.sdy_project
        return project is not None and project.is_uapc()

    @classmethod
    def set_a661_globals(cls, target_dir, project, configuration):
        enabled_specs = [
            Path(pair.split(',')[0]).name
            for pair in project.get_tool_prop_def(
                'GENERATOR', 'DISPLAY_ENABLED_PANELS', [], configuration
            )
        ]

        for application in display.get_roots():
            for specification in application.specifications:
                if (
                    cls.is_spec_a661(specification)
                    and Path(specification.pathname).name in enabled_specs
                ):
                    cls.a661_specs.append(specification)

        if len(cls.a661_specs) != 0:
            # assume one and only one root operator
            # TODO: what if several root operators?
            # TODO: what if both several specifications and root operators?
            specification = cls.a661_specs[0]
            root = project.get_tool_prop_def('GENERATOR', 'ROOTNODE', [], configuration)[0]
            id = specification.application_id
            cls.ua_base_name = '{0}_UA_{1}'.format(root.replace('::', '_'), id)
            cls.host = project.get_scalar_tool_prop_def(
                'GENERATOR', 'A661_SERVER_IP', '127.0.0.1', configuration
            )
            cls.port = project.get_scalar_tool_prop_def(
                'GENERATOR', 'A661_SERVER_PORT', '1231', configuration
            )
            cls.config_file = Path(
                cls.ansys_scade_dir / 'SCADE Display' / 'config' / 'a661_description' / 'a661.xml'
            ).as_posix()
            if project.get_bool_tool_prop_def(
                'GENERATOR', 'A661_USE_CUSTOM_CONFIG_FILE', False, configuration
            ):
                cls.config_file = project.get_scalar_tool_prop_def(
                    'GENERATOR', 'A661_CONFIG_FILE_PATH', cls.config_file, configuration
                )
                path = Path(cls.config_file)
                if not path.is_absolute:
                    path = Path(project.pathname).joinpath(cls.config_file)
                    cls.config_file = path.resolve().as_posix()
            cls.user_config = project.get_scalar_tool_prop_def(
                'GENERATOR', 'A661_USER_CONFIG', '', configuration
            )
            if cls.user_config != '':
                path = Path(cls.user_config)
                if not path.is_absolute:
                    path = Path(project.pathname).joinpath(cls.user_config)
                    cls.user_config = path.resolve().as_posix()


# ----------------------------------------------------------------------------
# list of services
# ----------------------------------------------------------------------------


def get_services():
    """Return the list of Generation services implemented by this module."""
    uaa = ('WUX2_UAA', ('-OnInit', A661UAA.init), ('-OnGenerate', A661UAA.generate))
    return [uaa]
